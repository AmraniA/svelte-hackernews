{"version":3,"file":"sw.js","sources":["../service-worker/main.js"],"sourcesContent":["const CACHE_NAME = `cache-v__CACHEVERSION__`;\nconst urlsToCache = __MANIFEST__; // eslint-disable-line no-undef\n\nself.addEventListener( 'install', event => {\n\tconsole.log( 'installing service worker' );\n\tevent.waitUntil(\n\t\tcaches.open( CACHE_NAME )\n\t\t\t.then( cache => {\n\t\t\t\treturn Promise.all(\n\t\t\t\t\turlsToCache.map( url => {\n\t\t\t\t\t\treturn cache.add( url ).catch( err => {\n\t\t\t\t\t\t\tconsole.error( `Error caching ${url}: ${err.message}` );\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t})\n\t\t\t.catch( err => {\n\t\t\t\tconsole.error( err.stack );\n\t\t\t})\n\t\t\t.then( () => {\n\t\t\t\tconsole.log( `cached ${urlsToCache.length} urls` );\n\t\t\t\tself.skipWaiting();\n\t\t\t})\n\t);\n});\n\n\nself.addEventListener( 'activate', event => {\n\tconsole.log( 'activating service worker' );\n\tevent.waitUntil(\n\t\tcaches.keys()\n\t\t\t.then( cacheNames => {\n\t\t\t\treturn Promise.all(\n\t\t\t\t\tcacheNames.map( cacheName => {\n\t\t\t\t\t\tif ( cacheName !== CACHE_NAME ) {\n\t\t\t\t\t\t\treturn caches.delete( cacheName );\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\t.then( () => self.clients.claim() );\n\t\t\t})\n\t);\n});\n\nself.addEventListener( 'fetch', event => {\n\tif ( !/^https?/.test( event.request.url ) ) return;\n\n\tevent.respondWith(\n\t\tcaches.open( CACHE_NAME )\n\t\t\t.then( cache => cache.match( event.request ) )\n\t\t\t.then( response => {\n\t\t\t\tif ( response ) return response;\n\n\t\t\t\tconst fetchRequest = event.request.clone();\n\n\t\t\t\treturn fetch( fetchRequest )\n\t\t\t\t\t.then( response => {\n\t\t\t\t\t\t// Check if we received a valid response\n\t\t\t\t\t\tif ( !response || response.status !== 200 || response.type !== 'basic' ) {\n\t\t\t\t\t\t\treturn response;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst responseToCache = response.clone();\n\n\t\t\t\t\t\tcaches.open( CACHE_NAME )\n\t\t\t\t\t\t\t.then( cache => {\n\t\t\t\t\t\t\t\t// no need to wait on this before responding\n\t\t\t\t\t\t\t\tcache.put( event.request, responseToCache ).catch( err => {\n\t\t\t\t\t\t\t\t\tconsole.error( `failed to cache ${event.request.url}: ${err.stack}` );\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn response;\n\t\t\t\t\t});\n\t\t\t})\n\t\t\t.catch( err => {\n\t\t\t\tconsole.error( err.stack );\n\t\t\t})\n\t);\n});"],"names":["const","CACHE_NAME","urlsToCache","self","addEventListener","event","console","log","waitUntil","caches","open","then","cache","Promise","all","map","url","add","catch","err","error","stack","skipWaiting","keys","cacheNames","cacheName","delete","clients","claim","test","request","respondWith","match","response","fetchRequest","clone","fetch","status","type","responseToCache","put"],"mappings":"wBAAAA,IAAMC,GAAa,uBACbC,2eAENC,MAAKC,iBAAkB,UAAW,SAAAC,GACjCC,QAAQC,IAAK,6BACbF,EAAMG,UACLC,OAAOC,KAAMT,GACXU,KAAM,SAAAC,GACN,MAAOC,SAAQC,IACdZ,EAAYa,IAAK,SAAAC,GAChB,MAAOJ,GAAMK,IAAKD,GAAME,MAAO,SAAAC,GAC9Bb,QAAQc,MAAO,iBAAiBJ,OAAQG,EAAW,gBAKtDD,MAAO,SAAAC,GACPb,QAAQc,MAAOD,EAAIE,SAEnBV,KAAM,WACNL,QAAQC,IAAK,UAAUL,EAAkB,gBACzCC,KAAKmB,mBAMTnB,KAAKC,iBAAkB,WAAY,SAAAC,GAClCC,QAAQC,IAAK,6BACbF,EAAMG,UACLC,OAAOc,OACLZ,KAAM,SAAAa,GACN,MAAOX,SAAQC,IACdU,EAAWT,IAAK,SAAAU,GACf,GAAKA,IAAcxB,EAClB,MAAOQ,QAAOiB,OAAQD,MAIxBd,KAAM,iBAAMR,MAAKwB,QAAQC,eAK9BzB,KAAKC,iBAAkB,QAAS,SAAAC,GACzB,UAAUwB,KAAMxB,EAAMyB,QAAQd,MAEpCX,EAAM0B,YACLtB,OAAOC,KAAMT,GACXU,KAAM,SAAAC,SAASA,GAAMoB,MAAO3B,EAAMyB,WAClCnB,KAAM,SAAAsB,GACN,GAAKA,EAAW,MAAOA,EAEvBjC,IAAMkC,GAAe7B,EAAMyB,QAAQK,OAEnC,OAAOC,OAAOF,GACZvB,KAAM,SAAAsB,GAEN,IAAMA,GAAgC,MAApBA,EAASI,QAAoC,UAAlBJ,EAASK,KACrD,MAAOL,EAGRjC,IAAMuC,GAAkBN,EAASE,OAUjC,OARA1B,QAAOC,KAAMT,GACXU,KAAM,SAAAC,GAENA,EAAM4B,IAAKnC,EAAMyB,QAASS,GAAkBrB,MAAO,SAAAC,GAClDb,QAAQc,MAAO,mBAAmBf,EAAMyB,QAAW,SAAKX,EAAS,WAI7Dc,MAGTf,MAAO,SAAAC,GACPb,QAAQc,MAAOD,EAAIE"}